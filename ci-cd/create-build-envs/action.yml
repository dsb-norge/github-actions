name: "Create common DSB CI/CD variables"
description: |
  Given the required input this action returns common DSB build environment variables with values.
  Common DSB build environment variables are the values needed to successfully build and deploy an app in DSB's infrastructure.
  Some variables are slightly different if the build was triggered from a PR. This is to support PR builds and deployments.
  Where possible values from input 'app-vars' are preferred.
author: "Peder Schmedling"
inputs:
  app-vars:
    description: "Specifications of application to build and/or deploy, created by the create-app-vars workflow."
    required: true
  github-json:
    description: "The 'github' context as JSON, passed from the calling workflow with '{{ toJSON(github) }}'"
    required: true
  secrets-json:
    description: "The 'secrets' context as JSON, passed from the calling workflow with '{{ toJSON(secrets) }}'"
    required: true
  vars-json:
    description: "The 'vars' context as JSON, passed from the calling workflow with '{{ toJSON(vars) }}'"
    required: true
  application-source-path:
    description: "The path to the application source code."
    required: false
    default: "./"
  application-vendor:
    description: "Vendor of application being built. Added as label in docker image."
    required: false
    default: Norwegian Directorate for Civil Protection
  docker-image-registry:
    description: "Docker image registry to push built image and tags to."
    required: false
    default: dsbacr.azurecr.io
  docker-image-repo:
    description: 'Docker image repo within "docker-image-registry" to push built image and tags to.'
    required: false
    default: dsb-norge
  docker-image-prune-keep-min-images:
    description: |
      Minimum number of images to keep for a given application when performing prune on the application image repo.
      Note: For images built from PRs this has no effect. A hardcoded value will be used when pruning PR images.
      Also note: This setting will only affects images older than what is set for 'docker-image-prune-keep-num-days'.
    required: false
    default: "30"
  docker-image-prune-keep-num-days:
    description: |
      Minimum number of days that images will be preserved for a given application when performing prune on the application image repo.
      Note: For images built from PRs this has no effect. A hardcoded value will be used when pruning PR images.
      Also note: All images newer than given value will be preserved regardless of what is set for 'docker-image-prune-keep-min-images'.
    required: false
    default: "180"
  acr-username:
    description: 'Username for given "docker-image-registry", user must have push pull rights. Used for docker build and docker push.'
    required: false
    default: ""
  acr-password:
    description: 'Password for the user given in "acr-username".'
    required: false
    default: ""
  acr-service-principal:
    description: 'Service principal with rights to delete from "docker-image-registry" (ACR). Used for teardown operation of ephemeral PR environments.'
    required: false
    default: ""
  maven-user-settings-repositories-yml:
    description: |
      A YAML list (as string) with information about maven repositories that will be used to create a maven settings.xml prior to invoking maven.
      The order of the repositories dictates in what order maven will search the repos for artifacts.

      Since github actions do not support github variables in action input default values:
        A special syntax is supported to allow for substituting in the caller repo fields of the YAML list.
        Notice the missing dollar sign preceding the '{{ }}'-expression below.
        Example:
          When called from a repo 'foo' owned by the organization 'bar' and the configuration:
            url: "https://maven.pkg.github.com/{{ github.repository }}"
          becomes:
            url: "https://maven.pkg.github.com/bar/foo"
    required: false
    default: |
      repositories:
        # for consuming artifacts available in the org
        - id: "github-dsb-norge"
          name: "GitHub: dsb-norge"
          url: "https://maven.pkg.github.com/dsb-norge/.github"
          username: "${env.DSB_GH_PKG_READ_USER}" # org variable ref. 'maven-extra-envs-from-github-yml'
          password: "${env.DSB_GH_PKG_READ_PAT}"  # org secret ref. 'maven-extra-envs-from-github-yml'
        # for publishing artifacts to the calling repo
        - id: "calling-repo"
          name: "Calling GitHub repo"
          url: "https://maven.pkg.github.com/{{ github.repository }}"
          username: "${env.GH_ACTION_ACTOR}"        # the GitHub action actor
          password: "${env.GH_ACTION_ACTOR_TOKEN}"  # the GitHub action actor's token
  maven-extra-envs-from-github-yml:
    description: |
      A YAML map (as string) with extra environment variables to define in same scope as maven, prior to invoking maven.
      The value of the environment variables are retrieved from one of the three github contexts: secrets, vars or github.

      Example, create environment variable 'MY_VAR' with value from
      the variable 'MY_ORG_VARIABLE' (retrieved from the github context 'vars'):
      ```yml
      from-variables:
        MY_VAR: "MY_ORG_VARIABLE"
      ```

      Github contexts ref. https://docs.github.com/en/actions/learn-github-actions/contexts#inputs-context
    required: false
    default: |
      from-secrets:
        DSB_GH_PKG_READ_PAT: "ORG_GITHUB_PACKAGES_READER_PAT"
      from-variables:
        DSB_GH_PKG_READ_USER: "ORG_GITHUB_PACKAGES_READER_USERNAME"
      from-github-context:
        GH_ACTION_ACTOR: "actor"
        GH_ACTION_ACTOR_TOKEN: "token"
  maven-build-project-deploy-to-repositories-yml:
    description: |
      A YAML map (as string), when deploying maven artifacts maven will be invoked once for each key-value pair.
      Each 'key::value' will be passed as 'id::default::url' to the maven deploy mojo as parameter 'altDeploymentRepository':
        key   -> id     : The id can be used to pick up the correct credentials from settings.xml. The given id must exist in the 'maven-user-settings-repositories-yml' input.
        -     -> default: Hardcoded value for maven2 repo compatibility
        value -> url    : The location of the repository
      ref. https://maven.apache.org/plugins/maven-deploy-plugin/deploy-mojo.html

      Since github actions do not support github variables in action input default values:
        A special syntax is supported to allow for substituting in the caller repo into the 'value'.
        Notice the missing dollar sign preceding the '{{ }}'-expression below.
        Example:
          When called from a repo 'foo' owned by the organization 'bar' and the configuration:
            my-repo-id: "https://maven.pkg.github.com/{{ github.repository }}"
          the result would be:
            my-repo-id: "https://maven.pkg.github.com/bar/foo"
    required: false
    default: |
      release-repositories:
        calling-repo: "https://maven.pkg.github.com/{{ github.repository }}"
      snapshot-repositories:
        calling-repo: "https://maven.pkg.github.com/{{ github.repository }}"
  sonarqube-token:
    description: "Token used for SonarQube app, see https://docs.sonarqube.org/latest/analysis/github-integration/"
    required: true
  jasypt-password:
    description: 'Jasypt password. Will be passed to maven build as environment variable named "JASYPT_LOCAL_ENCRYPTOR_PASSWORD"'
    required: false
    default: ""
  java-version:
    description: "Version of java specified when calling actions/setup-java"
    required: false
    default: "11"
  java-distribution:
    description: "Distribution of Java specified when calling actions/setup-java"
    required: false
    default: temurin
  nodejs-version:
    description: "Version of Node.js specified when calling actions/setup-node"
    required: false
    default: "16"
  github-repo-token:
    description: "Github repo token is required by: 1) Maven Sonar plugin to get PR information; 2) Adding comments from actions to github PRs."
    required: true
  app-config-repo:
    description: |
      Repo containing application configuration for apps used during deploy to ephemeral environment and static environments.
      This input is required when deploying apps.'
    required: false
    default: "dsb-norge/azure-kubernetes-config"
  app-config-repo-token:
    description: "Token for performing checkout and commits to the above repo during deploy. This input is required when deploying apps."
    required: false
    default: ""
  static-deploy-environments:
    description: |
      Comma separated list of static environments to deploy to.
      Application configuration for these must be defined in 'app-config-repo'.
    required: false
    default: dev, test
  static-deploy-from-default-branch-only:
    description: |
      Set this to 'false' to allow deploying to static environments from other branches than the default branch.
      The default is to allow only deploys from the default branch.
    required: false
    default: "true"
  pr-deploy-app-config-branch:
    description: |
      Name of branch in "app-config-repo" potentially containing modified app config used during deploy to ephemeral
      environment. If branch does not exist deploy will fallback to HEAD @ default branch.'
    required: false
    default: "${{ github.head_ref }}"
  pr-deploy-aks-cluster-name:
    description: "Name of AKS instance to use during deploy to ephemeral environment. This input is required when deploying to to ephemeral environments."
    required: false
    default: "aks-rg7-ss2-cm-k8s-cluster-dev-1"
  pr-deploy-aks-resource-group:
    description: |
      Name of resource group where the AKS instance to use during deploy to ephemeral environment lives. This input is
      required when deploying to to ephemeral environments.'
    required: false
    default: "rg7-ss2-cm-k8s-dev"
  pr-deploy-aks-creds:
    description: |
      Credentials to the AKS instance to use during deploy to ephemeral environment. This input is required when
      deploying to to ephemeral environments.
    required: false
    default: ""
  pr-deploy-additional-helm-values:
    description: "Additional values.yml overrides passed to Helm. The multiline string is saved to file and and passed to Helm using --vaules option."
    required: false
    default: ""
  pr-deploy-argo-applications-url:
    description: "URL to applications overview in ArgoCD. Used when creating comments on PRs during deploy to ephemeral environments."
    required: false
    default: "https://argo.dev.dsbnorge.no/applications"
  pr-deploy-comment-prefix:
    description: |
      Used when creating comments on PRs during deploy to ephemeral environments. All comments will be prfixed with this string.
      It is also used when looking for comment(s) to delete prior to creating a new comment. I.e. make sure this is a bit uniqe
      or you will loose comments on our PR. This string will in turn be prefixed with application name.
    required: false
    default: "auto-deployed to ephemeral PR environment:"
  github-dependencies-cache-enabled:
    description: |
      Whether to enable GitHub actions cache for dependencies.
      When this is enabled the dependencies directory is emptied before each build and a caching strategy using GitHub actions cache is applied.
      In short the strategy is:
        - For the builds of the default branch:
          - A unique cache is created for each unique combination of runner OS, month of year and dependencies file (hash of pom/lock file(s)).
          - If a unique cache exist, use it. A new cache is not created after successful build.
          - If a unique cache does not exist, ignore the build dependencies file and fall back to using the previous cache based off of unique
            combination of runner OS and month of year. A new cache is created after successful build, taking into account the build dependencies
            file.
          - If no cache exists for the current month of year, create a new cache. I.e. full re-download of dependencies the first build each
            month of the year. This is to avoid the cache from growing uncontrolled. A new cache is created after the first successful build,
            taking into account runner OS, month of year and the build dependencies file.
        - For the builds of non-default branches:
          - Caches from the default branch are available to feature branches.
          - A unique cache is created for each unique combination of runner OS, pull request number and dependencies file (hash of pom/lock
            file(s)).
          - If a unique cache exist, use it. A new cache is not created after successful build.
          - If a unique cache does not exist, ignore the build dependencies file and fall back to using the previous cache based off of unique
            combination of runner OS and pull request number. A new cache is created after successful build, taking into account the build
            dependencies file.
          - If no cache exists for the current pull request number, fall back to using the latest available cache from the default branch. I.e.
            when dependencies in a feature branch diverges from those of the default branch and a unique cache does not exist for the feature
            branch, a new cache is created for the feature branch based off of the latest cache from the default branch.
          - Caches from feature branches are not available to other branches. Therefore caches of feature branches are deleted upon merge of
            the feature branch. This behavior can be changed by setting 'github-dependencies-cache-delete-on-pr-close' to 'false'
    required: false
    default: "true"
  github-dependencies-cache-delete-on-pr-close:
    description: |
      Whether to delete the associated GitHub actions cache for dependencies when a PR is closed.
      Due to cache isolation, caches from non-default branches are not available from other branches in the repo.
      See https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows#restrictions-for-accessing-a-cache
      Set this to true to clean up on a faster cadence (than the default eviction policy) so as to ensure default branch is not thrashing.

      NOTE:
        `actions:write` permission is required to delete GitHub caches
        Ref: https://docs.github.com/en/rest/actions/cache?apiVersion=2022-11-28#delete-a-github-actions-cache-for-a-repository-using-a-cache-id
    required: false
    default: "true"
  github-dependencies-cache-path:
    description: |
      The path of where to restore to/save from when GitHub actions cache is enabled for dependencies.
      Leaving this empty causes the use of default value, which will vary depending on the 'application-type' field:
        - For maven application types (ex. 'spring-boot' and 'maven-library') this typically becomes "${HOME}/.m2/repository".
        - For node application types (ex. 'vue') this typically becomes "${HOME}/.npm".
    required: false
    default: "" # results in "${HOME}/.m2/repository"
outputs:
  json:
    description: "All envs as json"
    value: ${{ steps.build-env.outputs.json }}

runs:
  using: "composite"
  steps:
    # decide on git ref for app config repo branch
    - id: checkout-config-branch
      shell: bash
      env:
        GH_TOKEN: "${{ inputs.app-config-repo-token }}"
      run: |
        # Test if branch ${{ inputs.pr-deploy-app-config-branch }} exists in config repo

        set -o allexport; source "${{ github.action_path }}/helpers.sh"; set +o allexport;

        log-info 'Using GitHub token for application config repo from input 'app-config-repo-token' ...'
        GH_TOKEN_SANITIZED=${GH_TOKEN/ }
        mask-value "${GH_TOKEN_SANITIZED}"

        log-info 'Cloning branch "${{ inputs.pr-deploy-app-config-branch }}" of application repo "${{ inputs.app-config-repo }}" ...'
        TMP_FILE=./not-going-to-use-this
        if (
          git clone \
            --branch '${{ inputs.pr-deploy-app-config-branch }}' \
            "https://oauth2:${GH_TOKEN_SANITIZED}@github.com/${{ inputs.app-config-repo }}" \
            ${TMP_FILE}
        ); then
          set-output 'ref' "${{ inputs.pr-deploy-app-config-branch }}"
          log-info 'Ref "${{ inputs.pr-deploy-app-config-branch }}" exist in "${{ inputs.app-config-repo }}" and will be used for PR deploys.'
        else
          set-output 'ref' 'main'
          log-info 'Ref "${{ inputs.pr-deploy-app-config-branch }}" does not exist in "${{ inputs.app-config-repo }}", using "main" for PR deploys.'
        fi
        rm -rf ${TMP_FILE} || :

    # generate DSB build variables
    - id: build-env
      shell: bash
      env:
        APP_VARS_JSON: "${{ inputs.app-vars }}"
        # 'inputs.github-json' is loaded further down as it's too large to load into env var here, bash startup fails with argument too long
        SECRETS_JSON: "${{ inputs.secrets-json }}"
        VARS_JSON: "${{ inputs.vars-json }}"
        PR_HELM_VALUES_YML: "${{ inputs.pr-deploy-additional-helm-values }}"
        MVN_SETTINGS_REPOS_YML: "${{ inputs.maven-user-settings-repositories-yml }}"
        MVN_EXTRA_GH_ENVS_YML: "${{ inputs.maven-extra-envs-from-github-yml }}"
        MVN_DEPLOY_REPOS_YML: "${{ inputs.maven-build-project-deploy-to-repositories-yml }}"
      run: |
        # Define variables needed for build and deploy of DSB apps

        set -o allexport; source "${{ github.action_path }}/helpers.sh"; set +o allexport;

        # log inputs without secrets
        log-multiline "action input 'app-vars', the app vars JSON specification" "${APP_VARS_JSON}"
        log-multiline "action input 'vars-json', the 'vars' context" "${VARS_JSON}"
        log-multiline "action input 'pr-deploy-additional-helm-values'" "${PR_HELM_VALUES_YML}"
        log-multiline "action input 'maven-extra-envs-from-github-yml'" "${MVN_EXTRA_GH_ENVS_YML}"
        log-multiline "action input 'maven-build-project-deploy-to-repositories-yml'" "${MVN_DEPLOY_REPOS_YML}"

        # all inputs to the action as json in env var
        ALL_ACTION_INPUTS=$(cat <<'EOF'
        ${{ toJSON(inputs) }}
        EOF
        )

        # github context as json in env var
        GITHUB_JSON=$(cat <<'EOF'
        ${{ inputs.github-json }}
        EOF
        )

        # These fields will be set by action inputs and values from app vars will be ignored
        PROTECTED_ENVS=(
          acr-password
          acr-service-principal
          app-config-repo-token
          github-repo-token
          jasypt-password
          maven-extra-envs-from-github
          pr-deploy-aks-creds
          sonarqube-token
        )

        # Values for these fields will be handled specifically below
        #  - app-vars is used as basis for output and should not be added as separate field.
        #  - helm values requires special format, see further down.
        #  - docker-image-prune-* is hardcoded when running from a PR.
        #  - *-json is used in this action, contains sensitive information and should not be returned
        #  The rest is generated in this script and should not be added from app vars.
        SPECIAL_ENVS=(
          app-vars
          application-image-id
          application-source
          application-source-revision
          caller-repo-calling-branch
          caller-repo-default-branch
          caller-repo-is-on-default-branch
          docker-image-prune-keep-min-images
          docker-image-prune-keep-num-days
          github-dependencies-cache-key
          github-dependencies-cache-restore-keys
          github-json
          maven-build-project-deploy-to-repositories-yml
          maven-extra-envs-from-github-yml
          maven-user-settings-repositories-yml
          pr-deploy-additional-helm-values
          pr-deploy-app-config-branch
          pr-deploy-k8s-application-name
          pr-deploy-k8s-namespace
          secrets-json
          vars-json
        )

        # These does not contain any secrets and are safe to share
        # with other jobs and upload to github in a build artifact
        ENVS_WITHOUT_SECRETS=(
          acr-username
          app-config-repo
          application-build-timestamp
          application-description
          application-image-id
          application-image-name
          application-name
          application-source
          application-source-path
          application-source-revision
          application-type
          application-vendor
          application-version
          caller-repo-calling-branch
          caller-repo-default-branch
          caller-repo-is-on-default-branch
          docker-image-prune-keep-min-images
          docker-image-prune-keep-num-days
          docker-image-registry
          docker-image-repo
          github-dependencies-cache-delete-on-pr-close
          github-dependencies-cache-enabled
          github-dependencies-cache-key
          github-dependencies-cache-path
          github-dependencies-cache-restore-keys
          java-distribution
          java-version
          maven-build-project-arguments
          maven-build-project-command
          maven-build-project-deploy-release-artifacts
          maven-build-project-deploy-release-deploy-command
          maven-build-project-deploy-release-version-command
          maven-build-project-deploy-snapshot-artifacts
          maven-build-project-deploy-snapshot-deploy-command
          maven-build-project-deploy-snapshot-version-command
          maven-build-project-deploy-to-repositories-yml
          maven-build-project-goals
          maven-build-project-version-arguments
          maven-build-project-version-command
          maven-build-project-version-goals
          nodejs-build-project-custom-command-final
          nodejs-build-project-custom-command-pre-npm-ci
          nodejs-build-project-custom-command-pre-npm-run-build
          nodejs-build-project-custom-command-pre-npm-run-lint
          nodejs-version
          pr-deploy-additional-helm-values
          pr-deploy-aks-cluster-name
          pr-deploy-aks-resource-group
          pr-deploy-app-config-branch
          pr-deploy-argo-applications-url
          pr-deploy-comment-additional-text
          pr-deploy-comment-prefix
          pr-deploy-k8s-application-name
          pr-deploy-k8s-namespace
          spring-boot-build-image-arguments
          spring-boot-build-image-command
          spring-boot-build-image-pull-images-pre-build-yml
          spring-boot-build-image-goals
          spring-boot-build-image-version-arguments
          spring-boot-build-image-version-command
          spring-boot-build-image-version-goals
          static-deploy-environments
          static-deploy-from-default-branch-only
        )

        # Loop over all inputs to this action:
        #  - If the field is "special", do nothing
        #  - If field is protected: use value from this action inputs
        #  - If field does not exist in app vars: use value from this action inputs
        # This enables the possibility to override all but protected fields from app vars.
        INPUT_NAMES=($(echo "${ALL_ACTION_INPUTS}" | jq -r '.|keys|.[]'))
        for NAME in ${INPUT_NAMES[*]}; do
          if (is-protected "${NAME}" || ! has-field "${NAME}") && ! is-special "${NAME}"; then
            set-field "${NAME}" "$(get-input-val "${NAME}")"
          fi
        done

        # Handle 'pr-deploy-additional-helm-values' specifically
        #   app vars field is on JSON format whilst this actions input expects yml
        if has-field "pr-deploy-additional-helm-values"; then
          log-info "using 'pr-deploy-additional-helm-values' from app vars."
          log-info "converting app var 'pr-deploy-additional-helm-values' from JSON to valid yaml ..."
          PRETTY_VAL=$(echo "$(get-val 'pr-deploy-additional-helm-values')" | yq --input-format json --output-format yml --prettyPrint eval -)
        else
          log-info "using 'pr-deploy-additional-helm-values' from this action's input"
          log-info "validating 'pr-deploy-additional-helm-values' as valid yaml and stripping comments ..."
          PRETTY_VAL=$(echo "${PR_HELM_VALUES_YML}" | yq --input-format yml --output-format yml --prettyPrint eval '... comments=""' -)
        fi
        set-field "pr-deploy-additional-helm-values" "${PRETTY_VAL}"
        log-multiline "resulting value of 'pr-deploy-additional-helm-values'" "$(get-val 'pr-deploy-additional-helm-values')"

        # Differs depending on PR build or not, allow app vars to override
        PR_KUBERNETES_NAMESPACE="$(get-val 'application-name')"
        PR_KUBERNETES_APP_NAME="$(get-val 'application-name')"
        if [ '${{ github.event_name }}' == 'pull_request' ]; then
          PR_KUBERNETES_NAMESPACE=${PR_KUBERNETES_NAMESPACE}-pr-${{ github.event.number }}
          PR_KUBERNETES_APP_NAME=${PR_KUBERNETES_APP_NAME}-pr-${{ github.event.number }}
        fi
        # Only set field if not given in app vars
        if ! has-field "pr-deploy-k8s-application-name"; then
          set-field "pr-deploy-k8s-application-name" "${PR_KUBERNETES_APP_NAME}"
        fi
        # Only set field if not given in app vars
        if ! has-field "pr-deploy-k8s-namespace"; then
          set-field "pr-deploy-k8s-namespace" "${PR_KUBERNETES_APP_NAME}"
        fi

        # If PR build these are hardcoded, allow app vars to override when not running from a PR
        if [ '${{ github.event_name }}' == 'pull_request' ]; then
          set-field "docker-image-prune-keep-min-images" "5"
          set-field "docker-image-prune-keep-num-days" "0"
        else
          for NAME in docker-image-prune-keep-min-images docker-image-prune-keep-num-days; do
            if ! has-field "${NAME}"; then
              set-field "${NAME}" "$(get-input-val "${NAME}")"
            fi
          done
        fi

        # Calling repo branches information
        REPO_DEFAULT_BRANCH=$(curl -s https://api.github.com/repos/${{ github.repository }} -H "Authorization: bearer ${{ github.token }}" | jq -r .default_branch)
        REPO_CURRENT_BRANCH_IS_DEFAULT=false
        if [ "${{ github.ref_name }}" == "${REPO_DEFAULT_BRANCH}" ]; then
          REPO_CURRENT_BRANCH_IS_DEFAULT=true
        fi

        # Handled specifically as app vars field is on JSON format and
        # 'maven-user-settings-repositories-yml' is expected to be yaml format (as multiline string)
        if has-field "maven-user-settings-repositories-yml"; then
          log-info "using 'maven-user-settings-repositories-yml' from app vars."
          REPOS_YML="$(get-val 'maven-user-settings-repositories-yml')"
        else
          log-info "using 'maven-user-settings-repositories-yml' from this action's input"
          REPOS_YML="${MVN_SETTINGS_REPOS_YML}"
        fi

        log-info "validating app var 'maven-user-settings-repositories-yml' as yaml and stripping comments ..."
        PRETTY_VAL=$(echo "${REPOS_YML}" | yq --input-format yml --output-format yml --prettyPrint eval '... comments=""' -)

        log-info "injecting caller repo into 'maven-user-settings-repositories-yml' ..."
        # loops over repo list and substitutes in the actual caller repo in strings
        INJECTED_VAL=$(
          echo "${PRETTY_VAL}" |
            yq --input-format yml --output-format yml eval '
              .[] |=
              .[] |=
              .[] |=
              sub("{{ github.repository }}", "${{ github.repository }}")
            '
        )

        set-field "maven-user-settings-repositories-yml" "${INJECTED_VAL}"
        log-multiline "resulting value of 'maven-user-settings-repositories-yml'" "$(get-val 'maven-user-settings-repositories-yml')"

        # 'maven-extra-envs-from-github-yml' is expected to be yaml format (as multiline string)
        # and be converted to a JSON object named 'maven-extra-envs-from-github' compatible with the 'build-maven-project' action.
        start-group "create 'maven-extra-envs-from-github' from 'maven-extra-envs-from-github-yml'"
        if has-field "maven-extra-envs-from-github-yml"; then
          log-info "using 'maven-extra-envs-from-github-yml' from app vars."
          ENVS_YML="$(get-val 'maven-extra-envs-from-github-yml')"
        else
          log-info "using 'maven-extra-envs-from-github-yml' from this action's input"
          ENVS_YML="${MVN_EXTRA_GH_ENVS_YML}"
        fi
        log-info "converting app var 'maven-extra-envs-from-github-yml' to json ..."
        ENVS_JSON=$(echo "${ENVS_YML}" | yq --input-format yml --output-format json --prettyPrint eval -)

        # 'maven-extra-envs-from-github-yml' will be converted to json as # 'maven-extra-envs-from-github'
        # and populated with values from contexts in github

        ENVS_POPULATED_JSON='{}' # will hold named envs with values

        log-info "populating 'maven-extra-envs-from-github-yml' with values from the 'github' context ..."
        ENV_NAMES=($(echo "${ENVS_JSON}" | jq -r 'select(."from-github-context" != null) | ."from-github-context" | keys | .[]'))
        for ENV_NAME in ${ENV_NAMES[*]}; do
          log-info "  environment variable '${ENV_NAME}'"
          CONTEXT_FIELD=$(echo "${ENVS_JSON}" | jq -r --arg name "${ENV_NAME}" '."from-github-context" | .[$name]')
          log-info "   with value from secret '${CONTEXT_FIELD}'"
          if ! gh-context-has-field "${CONTEXT_FIELD}"; then
            log-error "A field named '${CONTEXT_FIELD}' does not exist in the current 'github' context!"
            exit 1
          fi
          set-envs-field "${ENV_NAME}" "$(gh-context-get-val ${CONTEXT_FIELD})" # modifies ENVS_POPULATED_JSON
        done

        log-info "populating 'maven-extra-envs-from-github-yml' from the 'secrets' context ..."
        ENV_NAMES=($(echo "${ENVS_JSON}" | jq -r 'select(."from-secrets" != null) | ."from-secrets" | keys | .[]'))
        for ENV_NAME in ${ENV_NAMES[*]}; do
          log-info "  environment variable '${ENV_NAME}'"
          CONTEXT_FIELD=$(echo "${ENVS_JSON}" | jq -r --arg name "${ENV_NAME}" '."from-secrets" | .[$name]')
          log-info "   with value from secret '${CONTEXT_FIELD}'"
          if ! secret-context-has-field "${CONTEXT_FIELD}"; then
            log-error "A field named '${CONTEXT_FIELD}' does not exist in the current 'secrets' context!"
            exit 1
          fi
          set-envs-field "${ENV_NAME}" "$(secret-context-get-val ${CONTEXT_FIELD})" # modifies ENVS_POPULATED_JSON
        done

        log-info "populating 'maven-extra-envs-from-github-yml' from the 'variables' context ..."
        ENV_NAMES=($(echo "${ENVS_JSON}" | jq -r 'select(."from-variables" != null) | ."from-variables" | keys | .[]'))
        for ENV_NAME in ${ENV_NAMES[*]}; do
          log-info "  environment variable '${ENV_NAME}'"
          CONTEXT_FIELD=$(echo "${ENVS_JSON}" | jq -r --arg name "${ENV_NAME}" '."from-variables" | .[$name]')
          log-info "   with value from secret '${CONTEXT_FIELD}'"
          if ! vars-context-has-field "${CONTEXT_FIELD}"; then
            log-error "A field named '${CONTEXT_FIELD}' does not exist in the current 'variables' context!"
            exit 1
          fi
          set-envs-field "${ENV_NAME}" "$(vars-context-get-val ${CONTEXT_FIELD})" # modifies ENVS_POPULATED_JSON
        done

        log-info "'maven-extra-envs-from-github-yml' now becomes JSON field named 'maven-extra-envs-from-github' ..."
        set-field "maven-extra-envs-from-github" "${ENVS_POPULATED_JSON}"

        log-info "removing 'maven-extra-envs-from-github-yml' from output ..."
        rm-field "maven-extra-envs-from-github-yml"
        end-group # create 'maven-extra-envs-from-github'

        # Handled specifically as app vars field is on JSON format and
        # 'maven-build-project-deploy-to-repositories-yml' is expected to be yaml format (as multiline string)
        if has-field "maven-build-project-deploy-to-repositories-yml"; then
          log-info "using 'maven-build-project-deploy-to-repositories-yml' from app vars."
          DEPLOY_REPOS_YML="$(get-val 'maven-build-project-deploy-to-repositories-yml')"
        else
          log-info "using default value for 'maven-build-project-deploy-to-repositories-yml' from this action's input"
          DEPLOY_REPOS_YML="${MVN_DEPLOY_REPOS_YML}"
        fi

        log-info "validating app var 'maven-build-project-deploy-to-repositories-yml' as yaml and stripping comments ..."
        PRETTY_VAL=$(echo "${DEPLOY_REPOS_YML}" | yq --input-format yml --output-format yml --prettyPrint eval '... comments=""' -)

        log-info "injecting caller repo into 'maven-build-project-deploy-to-repositories-yml' ..."
        # loops over repo maps and substitutes in the actual caller repo
        INJECTED_VAL=$(
          echo "${PRETTY_VAL}" |
            yq --input-format yml --output-format yml eval '
              .[] |=
              .[] |=
              sub("{{ github.repository }}", "${{ github.repository }}")
            '
        )

        set-field "maven-build-project-deploy-to-repositories-yml" "${INJECTED_VAL}"
        log-multiline "resulting value of 'maven-build-project-deploy-to-repositories-yml'" "$(get-val 'maven-build-project-deploy-to-repositories-yml')"

        # Handle GitHub actions cache related logic
        DEPS_CACHE_ENABLED="$(get-val 'github-dependencies-cache-enabled')"
        if [ ! "${DEPS_CACHE_ENABLED}" == 'true' ]; then
          log-info "Caching of dependencies using GitHub cache is not enabled."
        else
          start-group "Caching of dependencies using GitHub cache is enabled. Resolving configuration ..."

          # dependencies cache type
          DEPS_CACHE_TYPE_MAVEN_APP_TYPES=(
            'spring-boot'
            'maven-library'
          )
          DEPS_CACHE_TYPE_NPM_APP_TYPES=(
            'vue'
          )
          APP_TYPE="$(get-val 'application-type')"
          if [[ " ${DEPS_CACHE_TYPE_MAVEN_APP_TYPES[*]} " =~ " ${APP_TYPE} " ]]; then
            DEPS_CACHE_TYPE='maven'
          elif [[ " ${DEPS_CACHE_TYPE_NPM_APP_TYPES[*]} " =~ " ${APP_TYPE} " ]]; then
            DEPS_CACHE_TYPE='npm'
          else
            log-error "Dependencies caching for application type '${APP_TYPE}' has not been implemented!"
            exit 1
          fi
          log-info "Application type is '${APP_TYPE}', dependencies cache type will be '${DEPS_CACHE_TYPE}'."

          if [ ! "${DEPS_CACHE_TYPE}" == 'maven' ] && [ ! "${DEPS_CACHE_TYPE}" == 'npm' ]; then
            log-error "Dependencies caching for cache type '${DEPS_CACHE_TYPE}' has not been implemented!"
            exit 1
          fi

          # dependencies cache path
          if [ '' == "$(get-val 'github-dependencies-cache-path')" ]; then
            log-info "Dependencies directory 'github-dependencies-cache-path' not configured, using defaults."
            if [ "${DEPS_CACHE_TYPE}" == 'maven' ]; then
              DEPS_CACHE_PATH='${HOME}/.m2/repository' # single quotes to avoid env expansion
            elif [ "${DEPS_CACHE_TYPE}" == 'npm' ]; then
              DEPS_CACHE_PATH='${HOME}/.npm' # single quotes to avoid env expansion
            fi
            set-field 'github-dependencies-cache-path' "${DEPS_CACHE_PATH}"
          fi
          log-info "Configured to cache dependencies from directory '$(get-val "github-dependencies-cache-path")'"

          # all this to decide file pattern for dependencies cache key
          if ! has-field 'application-source-path'; then
            log-warn "'application-source-path' not defined, using default path."
            SRC_PATH='${GITHUB_WORKSPACE}'
          else
            SRC_PATH="$(realpath ${GITHUB_WORKSPACE}/$(get-val 'application-source-path'))"
          fi
          log-info "'application-source-path' is '${SRC_PATH}'"
          if [ "${DEPS_CACHE_TYPE}" == 'maven' ]; then
            if [ -f "${SRC_PATH}" ]; then
              log-info "Cache type is '${DEPS_CACHE_TYPE}' and 'application-source-path' exists as a file, the file will be used to determine 'github-dependencies-cache-key'."
              DEPS_CACHE_PATTERN="${SRC_PATH}"
            else
              if [ -d "${SRC_PATH}" ]; then
                log-info "Cache type is '${DEPS_CACHE_TYPE}' and 'application-source-path' exists as a directory, looking for pom.xml ..."
                POM_FILE_PATH="${SRC_PATH}/pom.xml"
                if [ -f "${POM_FILE_PATH}" ]; then
                  log-info "pom.xml found, using '$(ws-path "${POM_FILE_PATH}")' to determine 'github-dependencies-cache-key'."
                  DEPS_CACHE_PATTERN="${POM_FILE_PATH}"
                else
                  log-info "Unable to locate pom.xml, will use default file pattern for cache type '${DEPS_CACHE_TYPE}' in '$(ws-path "${SRC_PATH}")' to determine 'github-dependencies-cache-key'."
                  DEPS_CACHE_PATTERN="${SRC_PATH}/**/pom.xml"
                fi
              else
                log-warn "'application-source-path' does not exist as directory or file, will use default file pattern for cache type '${DEPS_CACHE_TYPE}' in root of the repo to determine 'github-dependencies-cache-key'."
                DEPS_CACHE_PATTERN="${GITHUB_WORKSPACE}/**/pom.xml"
              fi
            fi
          elif [ "${DEPS_CACHE_TYPE}" == 'npm' ]; then
            CACHE_KEY_FILE='package-lock.json'
            if [ -d "${SRC_PATH}" ]; then
              log-info "Cache type is '${DEPS_CACHE_TYPE}' and 'application-source-path' exists as a directory, looking for ${CACHE_KEY_FILE} ..."
              LOCK_FILE_PATH="${SRC_PATH}/${CACHE_KEY_FILE}"
              if [ -f "${LOCK_FILE_PATH}" ]; then
                log-info "${CACHE_KEY_FILE} found, using '$(ws-path "${LOCK_FILE_PATH}")' to determine 'github-dependencies-cache-key'."
                DEPS_CACHE_PATTERN="${LOCK_FILE_PATH}"
              else
                log-info "Unable to locate ${CACHE_KEY_FILE}, will use default file pattern for cache type '${DEPS_CACHE_TYPE}' in '$(ws-path "${SRC_PATH}")' to determine 'github-dependencies-cache-key'."
                DEPS_CACHE_PATTERN="${SRC_PATH}/**/${CACHE_KEY_FILE}"
              fi
            else
              if [ -f "${SRC_PATH}" ]; then
                log-info "Cache type is '${DEPS_CACHE_TYPE}' and 'application-source-path' exists as a file, looking for ${CACHE_KEY_FILE} ..."
                SRC_PATH_DIR="$(dirname "${SRC_PATH}")"
                LOCK_FILE_PATH="${SRC_PATH_DIR}/${CACHE_KEY_FILE}"
                if [ -f "${LOCK_FILE_PATH}" ]; then
                  log-info "${CACHE_KEY_FILE} found, using '$(ws-path "${LOCK_FILE_PATH}")' to determine 'github-dependencies-cache-key'."
                  DEPS_CACHE_PATTERN="${LOCK_FILE_PATH}"
                else
                  log-info "Unable to locate ${CACHE_KEY_FILE}, will use default file pattern for cache type '${DEPS_CACHE_TYPE}' in '$(ws-path "${SRC_PATH_DIR}")' to determine 'github-dependencies-cache-key'."
                  DEPS_CACHE_PATTERN="${SRC_PATH_DIR}/**/${CACHE_KEY_FILE}"
                fi
              else
                log-warn "'application-source-path' does not exist as directory or file, will use default file pattern for cache type '${DEPS_CACHE_TYPE}' in root of the repo to determine 'github-dependencies-cache-key'."
                DEPS_CACHE_PATTERN="${GITHUB_WORKSPACE}/**/${CACHE_KEY_FILE}"
              fi
            fi
          fi
          log-info "File pattern '${DEPS_CACHE_PATTERN}' will be used to determine 'github-dependencies-cache-key'."

          # cache keys
          # this makes a hash of hashes, supports multiple files in case file pattern is a glob
          CACHE_KEY_HASH_FULL="$(md5sum ${DEPS_CACHE_PATTERN} | LC_ALL=C sort | md5sum)"
          CACHE_KEY_HASH=${CACHE_KEY_HASH_FULL::8}

          log-info "Fallback base cache key format is: [os]-[cache type]-[month num]-[year num]-"
          CACHE_KEY_OS='${{ runner.os }}'
          CACHE_KEY_MONTH="$(date +%b)"
          CACHE_KEY_MINIMUM="${CACHE_KEY_OS,,}-${DEPS_CACHE_TYPE}-"
          CACHE_KEY_BASE_FALLBACK="${CACHE_KEY_MINIMUM}${CACHE_KEY_MONTH,,}-$(date +%y)-"
          log-info "Fallback base cache key is: ${CACHE_KEY_BASE_FALLBACK}"

          log-info "Base cache key format is: [os]-[cache type]-[month num]-[year num]-[hash]"
          CACHE_KEY_BASE="${CACHE_KEY_BASE_FALLBACK}${CACHE_KEY_HASH}"
          log-info "Base cache key is: ${CACHE_KEY_BASE}"

          log-info "Fallback PR cache key format: [os]-[cache type]-pr[pr number]-"
          CACHE_KEY_PR_FALLBACK="${CACHE_KEY_MINIMUM}pr${{ github.event.number }}-"
          log-info "Fallback PR cache key is: ${CACHE_KEY_PR_FALLBACK}"

          log-info "PR cache key format: [os]-[cache type]-pr[pr number]-[hash]"
          CACHE_KEY_PR="${CACHE_KEY_PR_FALLBACK}${CACHE_KEY_HASH}"
          log-info "PR cache key is: ${CACHE_KEY_PR}"

          if [ '${{ github.event_name }}' == 'pull_request' ]; then
            log-info "Running from pull request event, PR cache key will be used."
            CACHE_KEY="${CACHE_KEY_PR}"
          else
            log-info "Running from non-pull request event, base cache key will be used."
            CACHE_KEY="${CACHE_KEY_BASE}"
          fi
          set-field 'github-dependencies-cache-key' "${CACHE_KEY}"
          log-field 'github-dependencies-cache-key'

          # determine dependencies restore keys
          if [ '${{ github.event_name }}' == 'pull_request' ]; then
            log-info "Running from pull request event, PR cache keys are added to cache restore keys."
            CACHE_RESTORE_KEYS="$(printf '%s\n' ${CACHE_KEY_PR} ${CACHE_KEY_PR_FALLBACK} ${CACHE_KEY_BASE} ${CACHE_KEY_BASE_FALLBACK} ${CACHE_KEY_MINIMUM})"
          else
            log-info "Not Running from pull request, PR cache keys are not added to cache restore keys."
            CACHE_RESTORE_KEYS="$(printf '%s\n' ${CACHE_KEY_BASE} ${CACHE_KEY_BASE_FALLBACK})"
          fi
          set-field 'github-dependencies-cache-restore-keys' "${CACHE_RESTORE_KEYS}"
          log-field 'github-dependencies-cache-restore-keys'

          end-group # Caching of dependencies
        fi # end dependencies enabled == true

        # Generated fields, not possible to override from app vars
        IMAGE_ID="$(get-val 'docker-image-registry')/$(get-val 'docker-image-repo')/$(get-val 'application-image-name')"
        set-field "application-image-id"              "${IMAGE_ID}"
        set-field "pr-deploy-app-config-branch"       '${{ steps.checkout-config-branch.outputs.ref }}'
        set-field "application-source"                '${{ github.server_url }}/${{ github.repository }}'
        set-field "application-source-revision"       '${{ github.sha }}'
        set-field "caller-repo-default-branch"        "${REPO_DEFAULT_BRANCH}"
        set-field "caller-repo-calling-branch"        "${{ github.ref_name }}"
        set-field "caller-repo-is-on-default-branch"  "${REPO_CURRENT_BRANCH_IS_DEFAULT}"

        log-info "Number of envs: $(echo ${APP_VARS_JSON} | jq 'length')"

        # Separate output JSON not contain any secrets. Considered safe
        # to share with other jobs and upload to github in a build artifact
        ENVS_WITHOUT_SECRETS_STRING=${ENVS_WITHOUT_SECRETS[*]}
        JQ_SELECT_FIELDS_FORMAT="{\"${ENVS_WITHOUT_SECRETS_STRING// /\",\"}\"}"
        APP_VARS_JSON_NOT_SECRET=$(echo "${APP_VARS_JSON}" | jq "${JQ_SELECT_FIELDS_FORMAT}" | jq 'del(..|nulls)')

        OUT_DIR=./_create-build-envs
        OUT_JSON_FILE="${OUT_DIR}/$(get-val 'application-name').json"
        log-info "$(echo "${APP_VARS_JSON_NOT_SECRET}" | jq 'length') non-secret envs will be saved to file: ${OUT_JSON_FILE}"
        mkdir -p ${OUT_DIR}
        log-multiline "non-secret envs JSON" "$(echo "${APP_VARS_JSON_NOT_SECRET}" | tee "${OUT_JSON_FILE}")"

        set-output 'json-without-secrets-path' "${OUT_JSON_FILE}"
        set-output 'build-envs-artifact-name' "build-envs-$(get-val 'application-version')"

        set-multiline-output 'json' "${APP_VARS_JSON}"

    - uses: actions/upload-artifact@v3
      with:
        name: ${{ steps.build-env.outputs.build-envs-artifact-name }}
        path: ${{ steps.build-env.outputs.json-without-secrets-path }}
        if-no-files-found: error
        retention-days: 1
