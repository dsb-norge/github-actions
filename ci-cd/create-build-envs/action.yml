name: "Create common DSB CI/CD variables"
description: |
  Given the required input this action returns common DSB build environment variables with values.
  Common DSB build environment variables are the values needed to successfully build and deploy an app in DSB's infrastructure.
  Some variables are slightly different if the build was triggered from a PR. This is to support PR builds and deployments.
  Where possible values from input 'app-vars' are preferred.
author: "Peder Schmedling"
inputs:
  app-vars:
    description: "Specifications of application to build and/or deploy, created by the create-app-vars workflow."
    required: true
  github-json:
    description: "The 'github' context as JSON, passed from the calling workflow with '{{ toJSON(github) }}'"
    required: true
  secrets-json:
    description: "The 'secrets' context as JSON, passed from the calling workflow with '{{ toJSON(secrets) }}'"
    required: true
  vars-json:
    description: "The 'vars' context as JSON, passed from the calling workflow with '{{ toJSON(vars) }}'"
    required: true
  application-source-path:
    description: "The path to the application source code."
    required: false
    default: "./"
  application-vendor:
    description: "Vendor of application being built. Added as label in docker image."
    required: false
    default: Norwegian Directorate for Civil Protection
  docker-image-registry:
    description: "Docker image registry to push built image and tags to."
    required: false
    default: dsbacr.azurecr.io
  docker-image-repo:
    description: 'Docker image repo within "docker-image-registry" to push built image and tags to.'
    required: false
    default: dsb-norge
  docker-image-prune-keep-min-images:
    description: |
      Minimum number of images to keep for a given application when performing prune on the application image repo.
      Note: For images built from PRs this has no effect. A hardcoded value will be used when pruning PR images.
      Also note: This setting will only affects images older than what is set for 'docker-image-prune-keep-num-days'.
    required: false
    default: "30"
  docker-image-prune-keep-num-days:
    description: |
      Minimum number of days that images will be preserved for a given application when performing prune on the application image repo.
      Note: For images built from PRs this has no effect. A hardcoded value will be used when pruning PR images.
      Also note: All images newer than given value will be preserved regardless of what is set for 'docker-image-prune-keep-min-images'.
    required: false
    default: "180"
  acr-username:
    description: 'Username for given "docker-image-registry", user must have push pull rights. Used for docker build and docker push.'
    required: false
    default: ""
  acr-password:
    description: 'Password for the user given in "acr-username".'
    required: false
    default: ""
  acr-service-principal:
    description: 'Service principal with rights to delete from "docker-image-registry" (ACR). Used for teardown operation of ephemeral PR environments.'
    required: false
    default: ""
  maven-user-settings-repositories-yml:
    description: |
      A YAML list (as string) with information about maven repositories that will be used to create a maven settings.xml prior to invoking maven.
      The order of the repositories dictates in what order maven will search the repos for artifacts.

      Since github actions do not support github variables in action input default values:
        A special syntax is supported to allow for substituting in the caller repo fields of the YAML list.
        Notice the missing dollar sign preceding the '{{ }}'-expression below.
        Example:
          When called from a repo 'foo' owned by the organization 'bar' and the configuration:
            url: "https://maven.pkg.github.com/{{ github.repository }}"
          becomes:
            url: "https://maven.pkg.github.com/bar/foo"
    required: false
    default: |
      repositories:
        # for consuming artifacts available in the org
        - id: "github-dsb-norge"
          name: "GitHub: dsb-norge"
          url: "https://maven.pkg.github.com/dsb-norge/.github"
          username: "${env.DSB_GH_PKG_READ_USER}" # org variable ref. 'maven-extra-envs-from-github-yml'
          password: "${env.DSB_GH_PKG_READ_PAT}"  # org secret ref. 'maven-extra-envs-from-github-yml'
        # for publishing artifacts to the calling repo
        - id: "calling-repo"
          name: "Calling GitHub repo"
          url: "https://maven.pkg.github.com/{{ github.repository }}"
          username: "${env.GH_ACTION_ACTOR}"        # the GitHub action actor
          password: "${env.GH_ACTION_ACTOR_TOKEN}"  # the GitHub action actor's token
  maven-extra-envs-from-github-yml:
    description: |
      A YAML map (as string) with extra environment variables to define in same scope as maven, prior to invoking maven.
      The value of the environment variables are retrieved from one of the three github contexts: secrets, vars or github.

      Example, create environment variable 'MY_VAR' with value from
      the variable 'MY_ORG_VARIABLE' (retrieved from the github context 'vars'):
      ```yml
      from-variables:
        MY_VAR: "MY_ORG_VARIABLE"
      ```

      Github contexts ref. https://docs.github.com/en/actions/learn-github-actions/contexts#inputs-context
    required: false
    default: |
      from-secrets:
        DSB_GH_PKG_READ_PAT: "ORG_GITHUB_PACKAGES_READER_PAT"
      from-variables:
        DSB_GH_PKG_READ_USER: "ORG_GITHUB_PACKAGES_READER_USERNAME"
      from-github-context:
        GH_ACTION_ACTOR: "actor"
        GH_ACTION_ACTOR_TOKEN: "token"
  maven-build-project-deploy-to-repositories-yml:
    description: |
      A YAML map (as string), when deploying maven artifacts maven will be invoked once for each key-value pair.
      Each 'key::value' will be passed as 'id::default::url' to the maven deploy mojo as parameter 'altDeploymentRepository':
        key   -> id     : The id can be used to pick up the correct credentials from settings.xml. The given id must exist in the 'maven-user-settings-repositories-yml' input.
        -     -> default: Hardcoded value for maven2 repo compatibility
        value -> url    : The location of the repository
      ref. https://maven.apache.org/plugins/maven-deploy-plugin/deploy-mojo.html

      Since github actions do not support github variables in action input default values:
        A special syntax is supported to allow for substituting in the caller repo into the 'value'.
        Notice the missing dollar sign preceding the '{{ }}'-expression below.
        Example:
          When called from a repo 'foo' owned by the organization 'bar' and the configuration:
            my-repo-id: "https://maven.pkg.github.com/{{ github.repository }}"
          the result would be:
            my-repo-id: "https://maven.pkg.github.com/bar/foo"
    required: false
    default: |
      release-repositories:
        calling-repo: "https://maven.pkg.github.com/{{ github.repository }}"
      snapshot-repositories:
        calling-repo: "https://maven.pkg.github.com/{{ github.repository }}"
  sonarqube-token:
    description: "Token used for SonarQube app, see https://docs.sonarqube.org/latest/analysis/github-integration/"
    required: true
  jasypt-password:
    description: 'Jasypt password. Will be passed to maven build as environment variable named "JASYPT_LOCAL_ENCRYPTOR_PASSWORD"'
    required: false
    default: ""
  java-version:
    description: "Version of java specified when calling actions/setup-java"
    required: false
    default: "11"
  java-distribution:
    description: "Distribution of Java specified when calling actions/setup-java"
    required: false
    default: temurin
  nodejs-version:
    description: "Version of Node.js specified when calling actions/setup-node"
    required: false
    default: "16"
  github-repo-token:
    description: "Github repo token is required by: 1) Maven Sonar plugin to get PR information; 2) Adding comments from actions to github PRs."
    required: true
  app-config-repo:
    description: |
      Repo containing application configuration for apps used during deploy to ephemeral environment and static environments.
      This input is required when deploying apps.'
    required: false
    default: "dsb-norge/azure-kubernetes-config"
  app-config-repo-token:
    description: "Token for performing checkout and commits to the above repo during deploy. This input is required when deploying apps."
    required: false
    default: ""
  static-deploy-environments:
    description: |
      Comma separated list of static environments to deploy to.
      Application configuration for these must be defined in 'app-config-repo'.
    required: false
    default: dev, test
  static-deploy-from-default-branch-only:
    description: |
      Set this to 'false' to allow deploying to static environments from other branches than the default branch.
      The default is to allow only deploys from the default branch.
    required: false
    default: "true"
  pr-deploy-app-config-branch:
    description: |
      Name of branch in "app-config-repo" potentially containing modified app config used during deploy to ephemeral
      environment. If branch does not exist deploy will fallback to HEAD @ default branch.'
    required: false
    default: "${{ github.head_ref }}"
  pr-deploy-aks-cluster-name:
    description: "Name of AKS instance to use during deploy to ephemeral environment. This input is required when deploying to to ephemeral environments."
    required: false
    default: "aks-rg7-ss2-cm-k8s-cluster-dev-1"
  pr-deploy-aks-resource-group:
    description: |
      Name of resource group where the AKS instance to use during deploy to ephemeral environment lives. This input is
      required when deploying to to ephemeral environments.'
    required: false
    default: "rg7-ss2-cm-k8s-dev"
  pr-deploy-aks-creds:
    description: |
      Credentials to the AKS instance to use during deploy to ephemeral environment. This input is required when
      deploying to to ephemeral environments.
    required: false
    default: ""
  pr-deploy-additional-helm-values:
    description: "Additional values.yml overrides passed to Helm. The multiline string is saved to file and and passed to Helm using --vaules option."
    required: false
    default: ""
  pr-deploy-argo-applications-url:
    description: "URL to applications overview in ArgoCD. Used when creating comments on PRs during deploy to ephemeral environments."
    required: false
    default: "https://argo.dev.dsbnorge.no/applications"
  pr-deploy-comment-prefix:
    description: |
      Used when creating comments on PRs during deploy to ephemeral environments. All comments will be prfixed with this string.
      It is also used when looking for comment(s) to delete prior to creating a new comment. I.e. make sure this is a bit uniqe
      or you will loose comments on our PR. This string will in turn be prefixed with application name.
    required: false
    default: "auto-deployed to ephemeral PR environment:"
outputs:
  json:
    description: "All envs as json"
    value: ${{ steps.build-env.outputs.json }}

runs:
  using: "composite"
  steps:
    # decide on git ref for app config repo branch
    - id: checkout-config-branch
      shell: bash
      env:
        GH_TOKEN: "${{ inputs.app-config-repo-token }}"
      run: |
        # Test if branch ${{ inputs.pr-deploy-app-config-branch }} exists in config repo

        set -o allexport; source "${{ github.action_path }}/helpers.sh"; set +o allexport;

        log-info 'Using GitHub token for application config repo from input 'app-config-repo-token' ...'
        GH_TOKEN_SANITIZED=${GH_TOKEN/ }
        mask-value "${GH_TOKEN_SANITIZED}"

        log-info 'Cloning branch "${{ inputs.pr-deploy-app-config-branch }}" of application repo "${{ inputs.app-config-repo }}" ...'
        TMP_FILE=./not-going-to-use-this
        if (
          git clone \
            --branch '${{ inputs.pr-deploy-app-config-branch }}' \
            "https://oauth2:${GH_TOKEN_SANITIZED}@github.com/${{ inputs.app-config-repo }}" \
            ${TMP_FILE}
        ); then
          set-output 'ref' "${{ inputs.pr-deploy-app-config-branch }}"
          log-info 'Ref "${{ inputs.pr-deploy-app-config-branch }}" exist in "${{ inputs.app-config-repo }}" and will be used for PR deploys.'
        else
          set-output 'ref' 'main'
          log-info 'Ref "${{ inputs.pr-deploy-app-config-branch }}" does not exist in "${{ inputs.app-config-repo }}", using "main" for PR deploys.'
        fi
        rm -rf ${TMP_FILE} || :

    # generate DSB build variables
    - id: build-env
      shell: bash
      env:
        APP_VARS_JSON: "${{ inputs.app-vars }}"
        # 'inputs.github-json' is loaded further down as it's too large to load into env var here, bash startup fails with argument too long
        SECRETS_JSON: "${{ inputs.secrets-json }}"
        VARS_JSON: "${{ inputs.vars-json }}"
        PR_HELM_VALUES_YML: "${{ inputs.pr-deploy-additional-helm-values }}"
        MVN_SETTINGS_REPOS_YML: "${{ inputs.maven-user-settings-repositories-yml }}"
        MVN_EXTRA_GH_ENVS_YML: "${{ inputs.maven-extra-envs-from-github-yml }}"
        MVN_DEPLOY_REPOS_YML: "${{ inputs.maven-build-project-deploy-to-repositories-yml }}"
      run: |
        # Define variables needed for build and deploy of DSB apps

        set -o allexport; source "${{ github.action_path }}/helpers.sh"; set +o allexport;

        # log inputs without secrets
        log-multiline "action input 'app-vars', the app vars JSON specification" "${APP_VARS_JSON}"
        log-multiline "action input 'vars-json', the 'vars' context" "${VARS_JSON}"
        log-multiline "action input 'pr-deploy-additional-helm-values'" "${PR_HELM_VALUES_YML}"
        log-multiline "action input 'maven-extra-envs-from-github-yml'" "${MVN_EXTRA_GH_ENVS_YML}"
        log-multiline "action input 'maven-build-project-deploy-to-repositories-yml'" "${MVN_DEPLOY_REPOS_YML}"

        # all inputs to the action as json in env var
        ALL_ACTION_INPUTS=$(cat <<'EOF'
        ${{ toJSON(inputs) }}
        EOF
        )

        # github context as json in env var
        GITHUB_JSON=$(cat <<'EOF'
        ${{ inputs.github-json }}
        EOF
        )

        # These fields will be set by action inputs and values from app vars will be ignored
        PROTECTED_ENVS=(
          acr-password
          acr-service-principal
          app-config-repo-token
          github-repo-token
          jasypt-password
          maven-extra-envs-from-github
          pr-deploy-aks-creds
          sonarqube-token
        )

        # Values for these fields will be handled specifically below
        #  - app-vars is used as basis for output and should not be added as separate field.
        #  - helm values requires special format, see further down.
        #  - docker-image-prune-* is hardcoded when running from a PR.
        #  - *-json is used in this action, contains sensitive information and should not be returned
        #  The rest is generated in this script and should not be added from app vars.
        SPECIAL_ENVS=(
          app-vars
          application-image-id
          application-source
          application-source-revision
          caller-repo-calling-branch
          caller-repo-default-branch
          caller-repo-is-on-default-branch
          docker-image-prune-keep-min-images
          docker-image-prune-keep-num-days
          github-json
          maven-build-project-deploy-to-repositories-yml
          maven-extra-envs-from-github-yml
          maven-user-settings-repositories-yml
          pr-deploy-additional-helm-values
          pr-deploy-app-config-branch
          pr-deploy-k8s-application-name
          pr-deploy-k8s-namespace
          secrets-json
          vars-json
        )

        # These does not contain any secrets and are safe to share
        # with other jobs and upload to github in a build artifact
        ENVS_WITHOUT_SECRETS=(
          acr-username
          app-config-repo
          application-build-timestamp
          application-description
          application-image-id
          application-image-name
          application-name
          application-source
          application-source-path
          application-source-revision
          application-type
          application-vendor
          application-version
          caller-repo-calling-branch
          caller-repo-default-branch
          caller-repo-is-on-default-branch
          docker-image-prune-keep-min-images
          docker-image-prune-keep-num-days
          docker-image-registry
          docker-image-repo
          java-distribution
          java-version
          maven-build-project-arguments
          maven-build-project-command
          maven-build-project-deploy-release-artifacts
          maven-build-project-deploy-release-deploy-command
          maven-build-project-deploy-release-version-command
          maven-build-project-deploy-snapshot-artifacts
          maven-build-project-deploy-snapshot-deploy-command
          maven-build-project-deploy-snapshot-version-command
          maven-build-project-deploy-to-repositories-yml
          maven-build-project-goals
          maven-build-project-version-arguments
          maven-build-project-version-command
          maven-build-project-version-goals
          nodejs-build-project-custom-command-final
          nodejs-build-project-custom-command-pre-npm-ci
          nodejs-build-project-custom-command-pre-npm-run-build
          nodejs-build-project-custom-command-pre-npm-run-lint
          nodejs-version
          pr-deploy-additional-helm-values
          pr-deploy-aks-cluster-name
          pr-deploy-aks-resource-group
          pr-deploy-app-config-branch
          pr-deploy-argo-applications-url
          pr-deploy-comment-additional-text
          pr-deploy-comment-prefix
          pr-deploy-k8s-application-name
          pr-deploy-k8s-namespace
          spring-boot-build-image-arguments
          spring-boot-build-image-command
          spring-boot-build-image-pull-images-pre-build-yml
          spring-boot-build-image-goals
          spring-boot-build-image-version-arguments
          spring-boot-build-image-version-command
          spring-boot-build-image-version-goals
          static-deploy-environments
          static-deploy-from-default-branch-only
        )

        # Loop over all inputs to this action:
        #  - If the field is "special", do nothing
        #  - If field is protected: use value from this action inputs
        #  - If field does not exist in app vars: use value from this action inputs
        # This enables the possibility to override all but protected fields from app vars.
        INPUT_NAMES=($(echo "${ALL_ACTION_INPUTS}" | jq -r '.|keys|.[]'))
        for NAME in ${INPUT_NAMES[*]}; do
          if (is-protected "${NAME}" || ! has-field "${NAME}") && ! is-special "${NAME}"; then
            set-field "${NAME}" "$(get-input-val "${NAME}")"
          fi
        done

        # Handle 'pr-deploy-additional-helm-values' specifically
        #   app vars field is on JSON format whilst this actions input expects yml
        if has-field "pr-deploy-additional-helm-values"; then
          log-info "using 'pr-deploy-additional-helm-values' from app vars."
          log-info "converting app var 'pr-deploy-additional-helm-values' from JSON to valid yaml ..."
          PRETTY_VAL=$(echo "$(get-val 'pr-deploy-additional-helm-values')" | yq --input-format json --output-format yml --prettyPrint eval -)
        else
          log-info "using 'pr-deploy-additional-helm-values' from this action's input"
          log-info "validating 'pr-deploy-additional-helm-values' as valid yaml and stripping comments ..."
          PRETTY_VAL=$(echo "${PR_HELM_VALUES_YML}" | yq --input-format yml --output-format yml --prettyPrint eval '... comments=""' -)
        fi
        set-field "pr-deploy-additional-helm-values" "${PRETTY_VAL}"
        log-multiline "resulting value of 'pr-deploy-additional-helm-values'" "$(get-val 'pr-deploy-additional-helm-values')"

        # Differs depending on PR build or not, allow app vars to override
        PR_KUBERNETES_NAMESPACE="$(get-val 'application-name')"
        PR_KUBERNETES_APP_NAME="$(get-val 'application-name')"
        if [ '${{ github.event_name }}' == 'pull_request' ]
        then
          PR_KUBERNETES_NAMESPACE=${PR_KUBERNETES_NAMESPACE}-pr-${{ github.event.number }}
          PR_KUBERNETES_APP_NAME=${PR_KUBERNETES_APP_NAME}-pr-${{ github.event.number }}
        fi
        # Only set field if not given in app vars
        if ! has-field "pr-deploy-k8s-application-name"; then
          set-field "pr-deploy-k8s-application-name" "${PR_KUBERNETES_APP_NAME}"
        fi
        # Only set field if not given in app vars
        if ! has-field "pr-deploy-k8s-namespace"; then
          set-field "pr-deploy-k8s-namespace" "${PR_KUBERNETES_APP_NAME}"
        fi

        # If PR build these are hardcoded, allow app vars to override when not running from a PR
        if [ '${{ github.event_name }}' == 'pull_request' ]
        then
          set-field "docker-image-prune-keep-min-images" "5"
          set-field "docker-image-prune-keep-num-days" "0"
        else
          for NAME in docker-image-prune-keep-min-images docker-image-prune-keep-num-days; do
            if ! has-field "${NAME}"; then
              set-field "${NAME}" "$(get-input-val "${NAME}")"
            fi
          done
        fi

        # Calling repo branches information
        REPO_DEFAULT_BRANCH=$(curl -s https://api.github.com/repos/${{ github.repository }} -H "Authorization: bearer ${{ github.token }}" | jq -r .default_branch)
        REPO_CURRENT_BRANCH_IS_DEFAULT=false
        if [ "${{ github.ref_name }}" == "${REPO_DEFAULT_BRANCH}" ]; then
          REPO_CURRENT_BRANCH_IS_DEFAULT=true
        fi

        # Handled specifically as app vars field is on JSON format and
        # 'maven-user-settings-repositories-yml' is expected to be yaml format (as multiline string)
        if has-field "maven-user-settings-repositories-yml"; then
          log-info "using 'maven-user-settings-repositories-yml' from app vars."
          REPOS_YML="$(get-val 'maven-user-settings-repositories-yml')"
        else
          log-info "using 'maven-user-settings-repositories-yml' from this action's input"
          REPOS_YML="${MVN_SETTINGS_REPOS_YML}"
        fi

        log-info "validating app var 'maven-user-settings-repositories-yml' as yaml and stripping comments ..."
        PRETTY_VAL=$(echo "${REPOS_YML}" | yq --input-format yml --output-format yml --prettyPrint eval '... comments=""' -)

        log-info "injecting caller repo into 'maven-user-settings-repositories-yml' ..."
        # loops over repo list and substitutes in the actual caller repo in strings
        INJECTED_VAL=$(
          echo "${PRETTY_VAL}" |
            yq --input-format yml --output-format yml eval '
              .[] |=
              .[] |=
              .[] |=
              sub("{{ github.repository }}", "${{ github.repository }}")
            '
        )

        set-field "maven-user-settings-repositories-yml" "${INJECTED_VAL}"
        log-multiline "resulting value of 'maven-user-settings-repositories-yml'" "$(get-val 'maven-user-settings-repositories-yml')"

        # 'maven-extra-envs-from-github-yml' is expected to be yaml format (as multiline string)
        # and be converted to a JSON object named 'maven-extra-envs-from-github' compatible with the 'build-maven-project' action.
        if has-field "maven-extra-envs-from-github-yml"; then
          log-info "using 'maven-extra-envs-from-github-yml' from app vars."
          ENVS_YML="$(get-val 'maven-extra-envs-from-github-yml')"
        else
          log-info "using 'maven-extra-envs-from-github-yml' from this action's input"
          ENVS_YML="${MVN_EXTRA_GH_ENVS_YML}"
        fi
        log-info "converting app var 'maven-extra-envs-from-github-yml' to json ..."
        ENVS_JSON=$(echo "${ENVS_YML}" | yq --input-format yml --output-format json --prettyPrint eval -)

        # 'maven-extra-envs-from-github-yml' will be converted to json as # 'maven-extra-envs-from-github'
        # and populated with values from contexts in github

        ENVS_POPULATED_JSON='{}' # will hold named envs with values

        log-info "populating 'maven-extra-envs-from-github-yml' with values from the 'github' context ..."
        ENV_NAMES=($(echo "${ENVS_JSON}" | jq -r 'select(."from-github-context" != null) | ."from-github-context" | keys | .[]'))
        for ENV_NAME in ${ENV_NAMES[*]}; do
          log-info "  environment variable '${ENV_NAME}'"
          CONTEXT_FIELD=$(echo "${ENVS_JSON}" | jq -r --arg name "${ENV_NAME}" '."from-github-context" | .[$name]')
          log-info "   with value from secret '${CONTEXT_FIELD}'"
          if ! gh-context-has-field "${CONTEXT_FIELD}"; then
            log-error "A field named '${CONTEXT_FIELD}' does not exist in the current 'github' context!"
            exit 1
          fi
          set-envs-field "${ENV_NAME}" "$(gh-context-get-val ${CONTEXT_FIELD})" # modifies ENVS_POPULATED_JSON
        done

        log-info "populating 'maven-extra-envs-from-github-yml' from the 'secrets' context ..."
        ENV_NAMES=($(echo "${ENVS_JSON}" | jq -r 'select(."from-secrets" != null) | ."from-secrets" | keys | .[]'))
        for ENV_NAME in ${ENV_NAMES[*]}; do
          log-info "  environment variable '${ENV_NAME}'"
          CONTEXT_FIELD=$(echo "${ENVS_JSON}" | jq -r --arg name "${ENV_NAME}" '."from-secrets" | .[$name]')
          log-info "   with value from secret '${CONTEXT_FIELD}'"
          if ! secret-context-has-field "${CONTEXT_FIELD}"; then
            log-error "A field named '${CONTEXT_FIELD}' does not exist in the current 'secrets' context!"
            exit 1
          fi
          set-envs-field "${ENV_NAME}" "$(secret-context-get-val ${CONTEXT_FIELD})" # modifies ENVS_POPULATED_JSON
        done

        log-info "populating 'maven-extra-envs-from-github-yml' from the 'variables' context ..."
        ENV_NAMES=($(echo "${ENVS_JSON}" | jq -r 'select(."from-variables" != null) | ."from-variables" | keys | .[]'))
        for ENV_NAME in ${ENV_NAMES[*]}; do
          log-info "  environment variable '${ENV_NAME}'"
          CONTEXT_FIELD=$(echo "${ENVS_JSON}" | jq -r --arg name "${ENV_NAME}" '."from-variables" | .[$name]')
          log-info "   with value from secret '${CONTEXT_FIELD}'"
          if ! vars-context-has-field "${CONTEXT_FIELD}"; then
            log-error "A field named '${CONTEXT_FIELD}' does not exist in the current 'variables' context!"
            exit 1
          fi
          set-envs-field "${ENV_NAME}" "$(vars-context-get-val ${CONTEXT_FIELD})" # modifies ENVS_POPULATED_JSON
        done

        log-info "'maven-extra-envs-from-github-yml' now becomes JSON field named 'maven-extra-envs-from-github' ..."
        set-field "maven-extra-envs-from-github" "${ENVS_POPULATED_JSON}"

        log-info "removing 'maven-extra-envs-from-github-yml' from output ..."
        rm-field "maven-extra-envs-from-github-yml"

        # Handled specifically as app vars field is on JSON format and
        # 'maven-build-project-deploy-to-repositories-yml' is expected to be yaml format (as multiline string)
        if has-field "maven-build-project-deploy-to-repositories-yml"; then
          log-info "using 'maven-build-project-deploy-to-repositories-yml' from app vars."
          DEPLOY_REPOS_YML="$(get-val 'maven-build-project-deploy-to-repositories-yml')"
        else
          log-info "using default value for 'maven-build-project-deploy-to-repositories-yml' from this action's input"
          DEPLOY_REPOS_YML="${MVN_DEPLOY_REPOS_YML}"
        fi

        log-info "validating app var 'maven-build-project-deploy-to-repositories-yml' as yaml and stripping comments ..."
        PRETTY_VAL=$(echo "${DEPLOY_REPOS_YML}" | yq --input-format yml --output-format yml --prettyPrint eval '... comments=""' -)

        log-info "injecting caller repo into 'maven-build-project-deploy-to-repositories-yml' ..."
        # loops over repo maps and substitutes in the actual caller repo
        INJECTED_VAL=$(
          echo "${PRETTY_VAL}" |
            yq --input-format yml --output-format yml eval '
              .[] |=
              .[] |=
              sub("{{ github.repository }}", "${{ github.repository }}")
            '
        )

        set-field "maven-build-project-deploy-to-repositories-yml" "${INJECTED_VAL}"
        log-multiline "resulting value of 'maven-build-project-deploy-to-repositories-yml'" "$(get-val 'maven-build-project-deploy-to-repositories-yml')"

        # Generated fields, not possible to override from app vars
        IMAGE_ID="$(get-val 'docker-image-registry')/$(get-val 'docker-image-repo')/$(get-val 'application-image-name')"
        set-field "application-image-id"              "${IMAGE_ID}"
        set-field "pr-deploy-app-config-branch"       '${{ steps.checkout-config-branch.outputs.ref }}'
        set-field "application-source"                '${{ github.server_url }}/${{ github.repository }}'
        set-field "application-source-revision"       '${{ github.sha }}'
        set-field "caller-repo-default-branch"        "${REPO_DEFAULT_BRANCH}"
        set-field "caller-repo-calling-branch"        "${{ github.ref_name }}"
        set-field "caller-repo-is-on-default-branch"  "${REPO_CURRENT_BRANCH_IS_DEFAULT}"

        log-info "Number of envs: $(echo ${APP_VARS_JSON} | jq 'length')"

        # Separate output JSON not contain any secrets. Considered safe
        # to share with other jobs and upload to github in a build artifact
        ENVS_WITHOUT_SECRETS_STRING=${ENVS_WITHOUT_SECRETS[*]}
        JQ_SELECT_FIELDS_FORMAT="{\"${ENVS_WITHOUT_SECRETS_STRING// /\",\"}\"}"
        APP_VARS_JSON_NOT_SECRET=$(echo "${APP_VARS_JSON}" | jq "${JQ_SELECT_FIELDS_FORMAT}" | jq 'del(..|nulls)')

        OUT_DIR=./_create-build-envs
        OUT_JSON_FILE="${OUT_DIR}/$(get-val 'application-name').json"
        log-info "$(echo "${APP_VARS_JSON_NOT_SECRET}" | jq 'length') non-secret envs will be saved to file: ${OUT_JSON_FILE}"
        mkdir -p ${OUT_DIR}
        log-multiline "non-secret envs JSON" "$(echo "${APP_VARS_JSON_NOT_SECRET}" | tee "${OUT_JSON_FILE}")"

        set-output 'json-without-secrets-path' "${OUT_JSON_FILE}"
        set-output 'build-envs-artifact-name' "build-envs-$(get-val 'application-version')"

        set-multiline-output 'json' "${APP_VARS_JSON}"

    - uses: actions/upload-artifact@v3
      with:
        name: ${{ steps.build-env.outputs.build-envs-artifact-name }}
        path: ${{ steps.build-env.outputs.json-without-secrets-path }}
        if-no-files-found: error
        retention-days: 1
